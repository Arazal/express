{"mappings":"AAAA,sCAAsC;AAEtC,4BAA4B;AAE5B,oFAAoF;AAEpF,0DAA0D;AAC1D,gDAAgD;AAEhD,+CAA+C;AAC/C,6FAA6F;AAE7F,wGAAwG;AACxG,oEAAoE;AACpE,8BAA8B;AAC9B,mGAAmG;AACnG,SAAS;AACT,yFAAyF;AACzF,qBAAqB;AACrB,uBAAuB;AACvB,0BAA0B;AAC1B,oDAAoD;AACpD,2BAA2B;AAC3B,qBAAqB;AACrB,2DAA2D;AAC3D,QAAQ;AACR,QAAQ;AAER,MAAM;AAEN,kDAAkD;AAClD,yCAAyC;AAEzC,qCAAqC;AACrC,gDAAgD;AAChD,+CAA+C;AAC/C,+CAA+C;AAC/C,+CAA+C;AAC/C,qDAAqD;AAErD,+CAA+C;AAC/C,oHAAoH;AAEpH,4GAA4G;AAC5G,4BAA4B;AAC5B,wBAAwB;AACxB,uHAAuH;AACvH,gIAAgI;AAChI,kIAAkI;AAClI,8FAA8F;AAC9F,+HAA+H;AAC/H,8HAA8H;AAC9H,4HAA4H;AAC5H,iIAAiI;AACjI,0FAA0F;AAC1F,SAAS;AACT,2FAA2F;AAC3F,QAAQ;AAER,MAAM;AAEN,SAAS,YAAY,IAAI,EAAE,SAAS;IAClC,YAAY,aAAa;IACzB,IAAI,IAAI,GACJ,IAAI,YAAY;IACpB,IAAG,KAAK,UAAU,SAAS,uBAAuB;QAChD,IAAI;QACJ,IAAI;IACN,OAAO,IAAI,KAAK,UAAU,SAAS,wBAAwB;QACzD,IAAI;QACJ,IAAI;IACN;IACA,KAAK,MAAM,YAAY,eAAe,IAAI,SAAS,IAAI;IACvD,KAAK,MAAM,UAAU;IACrB,KAAK,OAAO,MAAM;QAAC,GAAG;QAAG,GAAG;QAAG,WAAW;IAAC,GAAG;QAC5C,UAAU;QACV,GAAG;QACH,GAAG;QACH,WAAW;QACX,MAAM;QACN,WAAW;IACb;AACF;AAEA,SAAS,KAAK,IAAI;IAChB,KAAK,IAAI,MAAM;QAAC,WAAW;IAAC;AAC9B;AAEA,SAAS,iBAAiB,oBAAoB;IAC5C,KAAK,eAAe;IAEpB,KAAK,MAAM,QAAQ,cAAc,QAAQ,SAAS,IAAI;QACpD,KAAK,OAAO,4DAA4D;QAExE,cAAc,OAAO;YACnB,SAAS;YACT,SAAS;YACT,SAAS;gBAAa,YAAY;YAAM;YACxC,aAAa;gBAAa,YAAY,MAAM;YAAI;YAChD,SAAS;gBAAa,KAAK;YAAM,EAAE,4DAA4D;QACjG;IACF;AACF","sources":["src/index.js"],"sourcesContent":["// gsap.registerPlugin(ScrollTrigger);\r\n\r\n// smoothScroll(\"#content\");\r\n\r\n// let getRatio = el => window.innerHeight / (window.innerHeight + el.offsetHeight);\r\n\r\n// gsap.utils.toArray(\"section\").forEach((section, i) => {\r\n//   section.bg = section.querySelector(\".bg\"); \r\n\r\n//   // Give the backgrounds some random images\r\n// //   section.bg.style.backgroundImage = `url(https://picsum.photos/1600/800?random=${i})`;\r\n  \r\n//   // the first image (i === 0) should be handled differently because it should start at the very top.\r\n//   // use function-based values in order to keep things responsive\r\n//   gsap.fromTo(section.bg, {\r\n//     backgroundPosition: () => i ? `50% ${-window.innerHeight * getRatio(section)}px` : \"50% 0px\"\r\n//   }, {\r\n//     backgroundPosition: () => `50% ${window.innerHeight * (1 - getRatio(section))}px`,\r\n//     ease:  \"none\",\r\n//     scrollTrigger: {\r\n//       trigger: section,\r\n//       start: () => i ? \"top bottom\" : \"top top\", \r\n//       end: \"bottom top\",\r\n//       scrub: true,\r\n//       invalidateOnRefresh: true // to make it responsive\r\n//     }\r\n//   });\r\n\r\n// });\r\n\r\n// const sections = gsap.utils.toArray(\"section\");\r\n// const lastIndex = sections.length - 1;\r\n\r\n// sections.forEach((section, i) => {\r\n//   section._bg = section.querySelector(\".bg\");\r\n//   section._h1 = section.querySelector(\"h1\");\r\n//   section._h3 = section.querySelector(\"h3\");\r\n//   section._h4 = section.querySelector(\"h4\");\r\n// //   section._car = section.getElementById(\"car\");\r\n  \r\n//   // Give the backgrounds some random images\r\n// //   section._bg.style.backgroundImage = `url(https://picsum.photos/${innerWidth}/${innerHeight*2}?random=${i})`;\r\n\r\n//   // Create a standalone ST instance, and use the progress value (0 - 1) to tween the timeline's progress\r\n//   ScrollTrigger.create({ \r\n//     trigger: section,\r\n//     start: ()=> i==0 ? \"top top\" : \"top bottom\", // The FIRST section will use a different start value than the rest\r\n//     end: ()=> i==lastIndex ? \"top top\" : \"bottom top\", // The LAST section will use a different start value than the rest    \r\n//     onRefresh: self => { // onRefresh (so it gets reset upon resize), create a timeline that moves the h1 + bg vertically      \r\n//       section._tl = gsap.timeline({paused:true, defaults:{ease:'none', overwrite:'auto'}}) \r\n//       // .fromTo(section._h1, {y:()=> i==0 ? 0 : (innerHeight/2)*1.25}, {y:()=> i==lastIndex ? 0 : (-innerHeight/2)*1.5}, 0)\r\n//       // .fromTo(section._h3, {x:()=> i==0 ? 0 : (innerHeight/2)*1.5}, {x:()=> i==lastIndex ? 0 : (-innerHeight/2)*1.5}, 0)\r\n//       // .fromTo(section._h4, {y:()=> i==0 ? 0 : (innerHeight/2)*2}, {y:()=> i==lastIndex ? 0 : (-innerHeight/2)*1.5}, 0)\r\n//       .fromTo(section._bg, {y:()=> i==0 ? -innerHeight/2 : 0}, {y:()=> i==lastIndex ? -innerHeight/2 : -innerHeight}, 0)\t  \t  \r\n//       .progress(self.progress); //use progress to position the timeline correctly      \r\n//     },\r\n//     onUpdate: self => { gsap.to(section._tl, {duration:0.75, progress:self.progress}); }\r\n//   });\r\n  \r\n// });\r\n\r\nfunction animateFrom(elem, direction) {\r\n  direction = direction || 1;\r\n  var x = 0,\r\n      y = direction * 100;\r\n  if(elem.classList.contains(\"gs_reveal_fromLeft\")) {\r\n    x = -100;\r\n    y = 0;\r\n  } else if (elem.classList.contains(\"gs_reveal_fromRight\")) {\r\n    x = 100;\r\n    y = 0;\r\n  }\r\n  elem.style.transform = \"translate(\" + x + \"px, \" + y + \"px)\";\r\n  elem.style.opacity = \"0\";\r\n  gsap.fromTo(elem, {x: x, y: y, autoAlpha: 0}, {\r\n    duration: 1.25, \r\n    x: 0,\r\n    y: 0, \r\n    autoAlpha: 1, \r\n    ease: \"expo\", \r\n    overwrite: \"auto\"\r\n  });\r\n}\r\n\r\nfunction hide(elem) {\r\n  gsap.set(elem, {autoAlpha: 0});\r\n}\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", function() {\r\n  gsap.registerPlugin(ScrollTrigger);\r\n  \r\n  gsap.utils.toArray(\".gs_reveal\").forEach(function(elem) {\r\n    hide(elem); // assure that the element is hidden when scrolled into view\r\n    \r\n    ScrollTrigger.create({\r\n      trigger: elem,\r\n      markers: false,\r\n      onEnter: function() { animateFrom(elem) }, \r\n      onEnterBack: function() { animateFrom(elem, -1) },\r\n      onLeave: function() { hide(elem) } // assure that the element is hidden when scrolled into view\r\n    });\r\n  });\r\n});"],"names":[],"version":3,"file":"index.579125c3.js.map","sourceRoot":"/__parcel_source_root/"}